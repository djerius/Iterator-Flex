package Iterator::Flex::Product;

# ABSTRACT: An iterator which produces a Cartesian product of iterators

use strict;
use warnings;
use experimental qw( signatures declared_refs refaliasing );

our $VERSION = '0.16';

use Iterator::Flex::Utils qw( RETURN STATE EXHAUSTION :IterAttrs :IterStates );
use Iterator::Flex::Factory;
use parent 'Iterator::Flex::Base';
use Ref::Util;
use List::Util;


use namespace::clean;

=method new

  $iterator = Iterator::Flex::Product->new( $iterable1, $iterable2, ..., ?\%pars );
  $iterator = Iterator::Flex::Product->new( key1 => $iterable1,
                              key2 => iterable2, ..., ?\%pars );

Returns an iterator which produces a Cartesian product of the input iterables.
If the input to B<iproduct> is a list of iterables, C<$iterator> will return an
array reference containing an element from each iterable.

If the input is a list of key, iterable pairs, C<$iterator> will return a
hash reference.

The iterables are converted into iterators via L<Iterator::Flex::Factory/to_iterator> if required.

All of the iterables must support the C<rewind> method.

The optional C<%pars> hash may contain standard L<signal
parameters|Iterator::Flex::Manual::Overview/Signal Parameters>.

The iterator supports the following capabilities:

=over

=item current

=item next

=item reset

=item rewind

=item freeze

This iterator may be frozen only if all of the iterables support the
C<prev> or C<__prev__> method.

=back

=cut


sub new ( $class, @args ) {
    my $pars = Ref::Util::is_hashref( $args[-1] ) ? pop @args : {};

    $class->_throw( parameter => 'not enough parameters' )
      unless @args;

    my @iterators;
    my @keys;

    # distinguish between ( key => iterator, key =>iterator ) and ( iterator, iterator );
    if ( Ref::Util::is_ref( $args[0] ) ) {
        @iterators = @args;
    }
    else {
        $class->_throw( parameter => 'expected an even number of arguments' )
          if @args % 2;

        while ( @args ) {
            push @keys,      shift @args;
            push @iterators, shift @args;
        }
    }

    $class->SUPER::new( { keys => \@keys, depends => \@iterators, value => [] }, $pars );
}

sub construct ( $class, $state ) {
    $class->_throw( parameter => "state must be a HASH reference" )
      unless Ref::Util::is_hashref( $state );

    $state->{value} //= [];

    my ( \@depends, \@keys, \@value, $thaw )
      = @{$state}{qw[ depends keys value thaw ]};

    # transform into iterators if required.
    my @iterators
      = map { Iterator::Flex::Factory->to_iterator( $_, { ( +EXHAUSTION ) => +RETURN } ) } @depends;

    # can only work if the iterators support a rewind method
    $class->_throw( parameter => "all iterables must provide a rewind method" )
      unless List::Util::all { defined $class->_can_meth( $_, 'rewind' ) } @iterators;

    $class->_throw( parameter => "number of keys not equal to number of iterators" )
      if @keys && @keys != @iterators;

    @value = map { $_->current } @iterators
      if $thaw;

    my @set = ( 1 ) x @value;

    my $self;
    my $iterator_state;
    my %params = (

        ( +_SELF ) => \$self,

        ( +STATE ) => \$iterator_state,

        ( +NEXT ) => sub {
            return $self->signal_exhaustion if $iterator_state == +IterState_EXHAUSTED;

            # first time through
            if ( !@value ) {

                for my $iter ( @iterators ) {
                    push @value, $iter->();

                    if ( $iter->is_exhausted ) {
                        return $self->signal_exhaustion;
                    }
                }

                @set = ( 1 ) x @value;
            }

            else {

                $value[-1] = $iterators[-1]->();
                if ( $iterators[-1]->is_exhausted ) {
                    $set[-1] = 0;
                    my $idx = @iterators - 1;
                    while ( --$idx >= 0 ) {
                        $value[$idx] = $iterators[$idx]->();
                        last unless $iterators[$idx]->is_exhausted;
                        $set[$idx] = 0;
                    }

                    if ( !$set[0] ) {
                        return $self->signal_exhaustion;
                    }

                    while ( ++$idx < @iterators ) {
                        $iterators[$idx]->rewind;
                        $value[$idx] = $iterators[$idx]->();
                        $set[$idx]   = 1;
                    }
                }

            }
            if ( @keys ) {
                my %value;
                @value{@keys} = @value;
                return \%value;
            }
            else {
                return [@value];
            }
        },

        ( +CURRENT ) => sub {
            return undef                    if !@value;
            return $self->signal_exhaustion if $iterator_state eq +IterState_EXHAUSTED;
            if ( @keys ) {
                my %value;
                @value{@keys} = @value;
                return \%value;
            }
            else {
                return [@value];
            }
        },

        ( +RESET )    => sub { @value = () },
        ( +REWIND )   => sub { @value = () },
        ( +_DEPENDS ) => \@iterators,
    );

    # can only freeze if the iterators support a current method
    if (
        List::Util::all { defined $class->_can_meth( $_, 'current' ) }
        @iterators
      )
    {

        $params{ +FREEZE } = sub {
            return [ $class, { keys => \@keys } ];
        };
        $params{ +_ROLES } = ['Freeze'];
    }

    $params{ +_NAME } = 'iproduct';
    return \%params;
}


__PACKAGE__->_add_roles( qw[
      State::Closure
      Next::ClosedSelf
      Current::Closure
      Reset::Closure
      Rewind::Closure
] );

1;

# COPYRIGHT
